#!/usr/bin/env node

/**
 * Markdown Enhancement Script
 * Transforms plain Obsidian markdown into Starlight-optimized content
 */

import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';

class MarkdownEnhancer {
  constructor() {
    this.patterns = {
      // Case citations - convert to badges
      caseCitation: /\*([^*]+v[^*]+)\*\s*\(([^)]+)\)/g,
      
      // Section references - highlight with code
      sectionRef: /s\s*(\d+[A-Za-z]*(?:\([^)]+\))?)/g,
      
      // Key definitions - convert to callouts
      definition: /^\*\*Definition[^*]*\*\*\s*\n(.+?)(?=\n\n|\n\*\*|$)/gm,
      
      // Authorities/Cases - convert to note callouts
      authorities: /^\*\*Authorities?\*\*\s*\n((?:- .+\n?)+)/gm,
      
      // Key points/elements - convert to structured lists
      keyPoints: /^\*\*(?:Key Points?|Elements?|Test Elements?)\*\*\s*\n((?:- .+\n?)+)/gm,
      
      // Lecturer notes - convert to tip callouts
      lecturerNotes: /^\*\*Lecturer Notes?\*\*\s*\n((?:- .+\n?)+)/gm,
      
      // Study tips - convert to tip callouts  
      studyTips: /^\*\*(?:Study Tips?|Practice Tips?|IRAC Structuring)\*\*\s*\n((?:- .+\n?)+)/gm,
      
      // Warnings - convert to caution callouts
      warnings: /^\*\*Warnings?\*\*\s*\n((?:- .+\n?)+)/gm,
      
      // Case tables - enhance with proper formatting
      caseTable: /\|\s*Element\s*\|\s*Detail\s*\|[\s\S]*?\n(?!\|)/g,
      
      // Blockquotes with citations - enhance formatting
      quoteCitation: />\s*\*"([^"]+)"\*\s*–\s*(.+)/g,
    };
  }

  /**
   * Transform plain markdown content to enhanced Starlight format
   */
  enhance(content, filePath) {
    let enhanced = content;

    // Extract frontmatter if present
    const frontmatterMatch = enhanced.match(/^---\n([\s\S]*?)\n---\n/);
    let frontmatter = '';
    let body = enhanced;
    
    if (frontmatterMatch) {
      frontmatter = frontmatterMatch[0];
      body = enhanced.slice(frontmatterMatch[0].length);
    }

    // Apply transformations to body content
    body = this.transformDefinitions(body);
    body = this.transformCaseCitations(body);
    body = this.transformSectionReferences(body);
    body = this.transformAuthorities(body);
    body = this.transformKeyPoints(body);
    body = this.transformLecturerNotes(body);
    body = this.transformStudyTips(body);
    body = this.transformWarnings(body);
    body = this.transformQuotations(body);
    body = this.transformCaseTables(body);
    body = this.addNavigationElements(body, filePath);

    return frontmatter + body;
  }

  transformDefinitions(content) {
    return content.replace(this.patterns.definition, (match, definition) => {
      return `:::note[Definition]\n${definition.trim()}\n:::`;
    });
  }

  transformCaseCitations(content) {
    return content.replace(this.patterns.caseCitation, (match, caseName, citation) => {
      return `<Badge text="${caseName}" variant="note" /> *(${citation})*`;
    });
  }

  transformSectionReferences(content) {
    return content.replace(this.patterns.sectionRef, (match, section) => {
      return `<Badge text="s ${section}" variant="tip" />`;
    });
  }

  transformAuthorities(content) {
    return content.replace(this.patterns.authorities, (match, authorities) => {
      return `:::note[Key Cases & Authorities]\n${authorities.trim()}\n:::`;
    });
  }

  transformKeyPoints(content) {
    return content.replace(this.patterns.keyPoints, (match, points) => {
      return `:::caution[Key Elements]\n${points.trim()}\n:::`;
    });
  }

  transformLecturerNotes(content) {
    return content.replace(this.patterns.lecturerNotes, (match, notes) => {
      return `:::tip[Lecturer Notes]\n${notes.trim()}\n:::`;
    });
  }

  transformStudyTips(content) {
    return content.replace(this.patterns.studyTips, (match, tips) => {
      return `:::tip[Study Tips]\n${tips.trim()}\n:::`;
    });
  }

  transformWarnings(content) {
    return content.replace(this.patterns.warnings, (match, warnings) => {
      return `:::caution[Important Warnings]\n${warnings.trim()}\n:::`;
    });
  }

  transformQuotations(content) {
    return content.replace(this.patterns.quoteCitation, (match, quote, citation) => {
      return `> *"${quote}"*\n>\n> — **${citation}**`;
    });
  }

  transformCaseTables(content) {
    // Enhanced table formatting with better styling
    return content.replace(this.patterns.caseTable, (match) => {
      return `<div class="case-analysis-table">\n\n${match}\n\n</div>`;
    });
  }

  addNavigationElements(content, filePath) {
    // Add automatic table of contents for long documents
    const headingCount = (content.match(/^#{2,3} /gm) || []).length;
    
    if (headingCount > 3) {
      const tocComment = '\n<!-- Automatic TOC will be generated by Starlight -->\n\n';
      return tocComment + content;
    }
    
    return content;
  }

  /**
   * Generate enhanced frontmatter based on file path and content
   */
  generateFrontmatter(originalFrontmatter, filePath, content) {
    const pathParts = filePath.split('/');
    const filename = pathParts[pathParts.length - 1].replace('.md', '');
    
    // Extract course code and week from path
    const courseMatch = filePath.match(/(LAW\d{5})/);
    const weekMatch = filePath.match(/Week (\d+)/);
    
    let enhanced = originalFrontmatter || '---\n---';
    
    // Add sidebar configuration if not present
    if (!enhanced.includes('sidebar:')) {
      const order = weekMatch ? parseInt(weekMatch[1]) : 99;
      enhanced = enhanced.replace('---\n---', 
        `---\nsidebar:\n  order: ${order}\n---`
      );
    }
    
    return enhanced;
  }
}

/**
 * Process a single markdown file
 */
async function processFile(filePath) {
  try {
    const content = await readFile(filePath, 'utf-8');
    const enhancer = new MarkdownEnhancer();
    const enhanced = enhancer.enhance(content, filePath);
    
    await writeFile(filePath, enhanced);
    console.log(`Enhanced: ${filePath}`);
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error.message);
  }
}

// CLI usage
if (process.argv.length > 2) {
  const filePath = process.argv[2];
  processFile(filePath);
}

export { MarkdownEnhancer, processFile };